//|===========================================================================
//|  Team Name: Compiler Builders 33
//|
//|  Programmers:
//|		Megan Chipman
//|		Jason Lancaster
//|		Victoria Proetsch
//|
//|  Course:	COP3402, Fall 2016
//|  Date:      Sept 22, 2016
//|---------------------------------------------------------------------------
//|  Language:	C
//|  File:		parser.c
//|  Purpose:	Assignment #3, Implement a parser and code generator for PL/0
//|
//|  Notes:
//|
//|===========================================================================

//Included Libraries
#include <stdio.h>
#include <stdlib.h>
#include "tokens.h"
#include "error.h"
#include "lexer.h"

void program();
void block();
void const_declaration();
void var_declaration();
void proc_declaration();
void statement();
void condition();
void expression();
void term();
void factor();
token_type relation(token_type); // return type?
void advance();

/*THIS IS THE GLOBAL TOKEN STORAGE AVAILABLE TO ALL PARSER FUNCTIONS*/
aToken_type* tok;

int main() {

    //Declare and Initialize Variables:
    //aToken_type *toke;

    //Open and Declare File Pointers:
    FILE *source;
    FILE *clean;

    source = fopen("tester.txt", "r");
    clean = fopen("clean.pl0", "w");

    //Check if pointers are valid:
    if (source == NULL){
        printf("Unable to open file.\n");
    }

    if (clean == NULL){
        printf("Unable to open file.\n");
    }

    //Remove Comments from Source File:
    removeComments(source, clean);


    fclose(source);
    fclose(clean);

    //Have Clean point to the new, clean file:
    clean = fopen("clean.pl0", "r");

    //run the lexer
    do_lex(clean);

    while(true)
    {
        //Get the tokens from the shared array of tokens generated by lexer
        //toke = getNextToken(clean); --changed to use the global tok and functions from tokens.h
        tok = nextToken();
        if (tok == NULL){
            printf("invalid token\n");
            break;
        }

        // halt if nullsym is returned
        if ( tok->t == 1 )
            break;

        //Display the appropriate token, then free it
        //printf("token: ");
        displayToken(tok);
        //printf("\n");
        //addToken(tok); --this must be done in the lexer as it reads the clean file
        freeToken(tok);
    }

    //Back to the beginning
    tok = rewindParseTokens();

    //Close the cleanFile pointer
    fclose(clean);
}


// *** PARSER ***

//advance stores next token in tok
void advance(){
    tok = nextToken();
}

// comments
void program(){
	block();

	if(tok->t != periodsym){
		error(9);
		exit(1);
	}
	advance();

	printf("No errors, the program is syntactically correct.\n");

}

// comments
void block(){
	const_declaration();
	var_declaration();
	proc_declaration();
	statement();
}

// comments
void const_declaration(){

	if(tok->t != constsym){
		return;
	}
	advance();

	while(tok->t != commasym){

		if(tok->t != identsym){
			error(4);
			exit(1);
		}
		advance();

		if(tok->t != eqsym){
			error(3);
			exit(1);
		}
		advance();

		// are we testing fornumbersym
		// or if its a digit [isn't this tested in lexer
		// and it assigns numbersym?]
		if(tok->t != numbersym){
			error(2);
			exit(1);
		}
		advance();
	}

	if(tok->t != semicolonsym){
		error(5);
		exit(1);
	}

	advance();

}

// comments
void var_declaration(){

	if(tok->t != varsym){
		return;
	}
	advance();

	while(tok->t != commasym){

		if(tok->t != identsym){
			error(4);
			exit(1);
		}
		advance();
	}

	if(tok->t != semicolonsym){
		error(5);
		exit(1);
	}

	advance();
}

// comments
void proc_declaration(){

	if(tok->t != procsym){
		return;
	}
	while(tok->t == procsym){
		advance();

		if(tok->t != identsym){
			error(4);
			exit(1);
		}
		advance();

		if(tok->t != semicolonsym){
			error(5);
			exit(1);
		}
		advance();
		block();

		if(tok->t != semicolonsym){
			error(5);
			exit(1);
		}
		advance();
	}

}

// comments
void statement(){

	switch(tok->t){
		case identsym:
			advance();

			if(tok->t != becomessym){
				error(0); // !!! input the error code !!!
				exit(1);
			}
			advance();
			expression();
			break;

		case callsym:
			advance();

			if(tok->t != identsym){
				error(14);
				exit(1);
			}
			advance();
			break;

		case beginsym:
			advance();
			statement();

			while(tok->t == semicolonsym){
				advance();
				statement();
			}

			if(tok->t != endsym){
				error(0); // !!! input the error code !!!
				exit(1);
			}
			advance();
			break;

		case ifsym:
			advance();
			condition();

			if(tok->t != thensym){
				error(16);
				exit(1);
			}
			advance();
			break;

		case whilesym:
			advance();
			condition();

			if(tok->t != dosym){
				error(18);
				exit(1);
			}
			advance();
			statement();
			break;

		default:
			//error(7); // no error, epsilon is a valid string for statement
			break;

		} // END switch

}

// comments
void condition(){

	if(tok->t == oddsym){
		advance();
		expression();
	}else{
		expression();

		if(tok != relation(tok->t)){
			error(20);
			exit(1);

		}
		advance();
		expression();
	}
}

token_type relation(token_type tok){

	switch(tok){
		case eqsym:
			return eqsym;
			break;
		case neqsym:
			return neqsym;
			break;
		case lessym:
			return lessym;
			break;
		case leqsym:
			return leqsym;
			break;
		case gtrsym:
			return gtrsym;
			break;
		case geqsym:
			return geqsym;
			break;
		default:
			error(20);
			exit(1);
			break;
	}

}

// comments
void expression(){

	if(tok->t != plussym || tok->t != minussym){
		return;
	}

	term();

	while(tok->t == plussym || tok->t == minussym){
		advance();
		term();
	}

}

// comments
void term(){
	factor();

	while(tok->t == multsym || tok->t == slashsym){
		advance();
		factor();
	}
}

// comments
void factor(){
	switch(tok->t){

		case identsym:
			advance();
			break;

		case numbersym:
			advance();
			break;

		case lparentsym:
			advance();
			expression();

			if(tok->t != rparentsym ){
				error(22);
				exit(1);
			}
			advance();
			break;

		default:
			error(23); // !!! check this !!!
			exit(1);
			break;

	} // END switch


}





